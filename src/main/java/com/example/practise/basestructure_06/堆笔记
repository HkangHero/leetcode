1、TreeMap 不会覆盖，有序表是不会加重复的key。
2、优先级队列可以加入重复的key，有序


建立堆过程:
1、从上到下的方法是 N*LogN
2、从下到上的方法是 N
把堆的最大值和堆末尾的值交换，然后减少堆带线啊哦之后，再去调整堆，周而复始，时间复杂化度N*logN 基于比较排序


什么是堆？=>（大堆  小堆）
大堆：每颗子树的最大值在头节点
小堆：每颗子树的最小值在头节点
是完全二叉树 全满/空/一个节点/从左往右（不满的层按从左到右）
arr[0,1,2,3,4,5,6]
对任何一个节点 左孩子: i*2+1
               右孩子： i*2+2
               父亲: i-1/2

数组实现：arr[] 12 6  8 10 4
12直接加入
6加入，对比父亲(i-1/2)如果比父节点大，交换，继续 (没有大与父，所以不需要交换)
8加入 不叫唤
10加入，发现(4-1)/2 =1 与arr[1]对比大，所以交换，继续和父对比
.
.
.

删除最大值：
将根节点和数组最后一个交换，size-- 新的根节点在子孩子中找到最大的，交换，继续在子孩子找，如果有比它大的，交换。。继续  判断（if（size < i）） 不能超过



堆有N给元素 高度为logN，排序是NlongN
堆排序过程：  数组最后一个值与根节点交换，此时根节点与树断开，已经出来最大值，然后交换了根节点，再次与子节点对比放在合适的位置，调整好大根堆，此时，根节点是最大值，及时与数组最后一个值呼唤，这时候出来了的倒数第二大。。。